# Нахождение минимальной "лестницы слов"

## Содержание:
 * [Теоретическая часть](#Теоретическая-часть)
 * [Пояснение к програмной реализации](#Пояснение-к-програмной-реализации)

 
## Теоретическая часть
  * [Возможные алгоритмы решения](#Возможные-алгоритмы-решения)
  * [Граф](#Граф)
  * [Преобразование коллекции слов в граф](#Преобразование-коллекции-слов-в-граф)
  * [Нахождение минимальной "лестницы слов" по графу](#Нахождение-минимальной-лестницы-слов-по-графу)


Требуется преобразовать одно слово в другое. Изменения должны происходить постепенно, по букве на каждом шаге, причем промежуточные слова также должны являться словами некоторого языка.

### Возможные алгоритмы решения
  * [Полный перебор](#Полный-перебор)
  * [С помощью графа](#С-помощью-графа)
  * [Алгоритм Вагнера-Фишера (похожая задача)](#Алгоритм-Вагнера-Фишера)
  
 
 #### Полный перебор
 Предположим, что необходимо преобразовать слово FOOL в слово SAGE. Тогда для нахождения цепочки слов выпишем все слова, отличающиеся от слова FOOL ровно на один символ. Сделаем то же самое для полученных слов и так далее рекурсивно, пока не встретится слово SAGE. Очевидно, что данный алгоритм неэффективен как по времени, так и по памяти.
 
 #### С помощью графа
 Построим граф, вршинами которого будут слова определенной длины, а ребра соединяют слова, различающиеся только в одном символе. Тогда с помощью поиска в ширину можно найти эффективный путь до конечного слова.
 
#### Алгоритм Вагнера-Фишера (похожая задача)
Данный алгоритм используется в тех случаях, когда не важно, чтобы в цепочки слов были слова, существующие в языке. Также не важна длина начального и конечного слов, так как можно как добавлять, так и удалять символы.

Искомое расстояние формируется через вспомогательную функцию D(M,N), находящую редакционное расстояние для подстрок S1[0..M] и S2[0..N]. Тогда полное редакционное расстояние будет равно расстоянию для подстрок полной длины: d(S1,S2) = DS1,S2(M,N).

Самоочевидным фактом, является то, что:

D(0,0) = 0. 

Действительно, пустые строки и так совпадают.

Также, ясны значения для:

D(i, 0) = i;
D(0, j) = j.

Действительно, любая строка может получиться из пустой, добавлением нужного количества нужных символов, любые другие операции будут только увеличивать оценку.

В общем случае чуть сложнее:

D(i,j) = D(i-1,j-1), если S1[i] = S2[j],
иначе D(i,j) = min( D(i-1,j), D(i,j-1), D(i-1,j-1) ) + 1.

В данном случае, мы выбираем, что выгоднее: удалить символ (D(i-1,j)), добавить (D(i,j-1)), или заменить (D(i-1,j-1)).

Нетрудно понять, что алгоритму получения оценки не требуется памяти больше чем два столбца, текущий (D( i  ,* )) и предыдущий (D( i-1 , * )). Однако в полном объеме матрица нужна для восстановления редакционного предписания. Начиная из правого нижнего угла матрицы (M,N) мы идем в левый верхний, на каждом шаге ища минимальное из трёх значений:
если минимально (D(i-1, j) + 1), добавляем удаление символа S1[i] и идём в (i-1, j);
если минимально (D(i, j-1) + 1), добавляем вставку символа S1[i] и идём в (i, j-1);
если минимально (D(i-1, j-1) + m), где m = 1, если S1[i] != S2[j], иначе m = 0; после чего идём в (i-1, j-1) и добавляем замену если m = 1.
Здесь (i, j) — клетка матрицы, в которой мы находимся на данном шаге. Если минимальны два из трёх значений (или равны все три), это означает, что есть 2 или 3 равноценных редакционных предписания.

В итоге потребуется O(|S1| * |S2|) времени и O(|S1| * |S2|) памяти.

### Граф

Граф, или неориентированный граф ***G*** — это упорядоченная пара ***G:=(V,E)*** , где ***V*** — это непустое множество вершин или узлов, а ***E*** — множество пар (в случае неориентированного графа — неупорядоченных) вершин, называемых рёбрами.

Маршрутом в графе называют конечную последовательность вершин, в которой каждая вершина (кроме последней) соединена со следующей в последовательности вершиной ребром. Цепью называется маршрут без повторяющихся рёбер. Простой цепью называется маршрут без повторяющихся вершин (откуда следует, что в простой цепи нет повторяющихся рёбер).

### Преобразование коллекции слов в граф

Для построения такого графа существует два подхода. Можем в качестве вершин сделать все слова определенной длины, а затем, сравнивая все слова, выстраивать рёбра. Но в таком случае, получается слишком много сравнений, что неэффективно (*O(n^2)*).

![image](https://aliev.me/runestone/static/pythonds/_images/wordgraph.png)

Согласно другому подходу, у нас есть огромное количество корзин, на каждой из которых написано четырёхбуквенное слово, в котором одна буква заменена подчёркиванием. Для примера у нас есть корзина с меткой ***pop_*** . При обработке каждого слова в списке мы сравниваем его с корзинами, используя " _ " для произвольной подстановки. Таким образом, с ***pop_*** можно связать и ***pope***, и ***pops***. Каждый раз, когда находится связь с корзиной, мы кладём в неё слово. Когда все слова разложены, мы знаем, что всё, лежащее в одной корзине, должно быть связано между собой.

![image](https://aliev.me/runestone/static/pythonds/_images/wordbuckets.png)

### Нахождение минимальной "лестницы слов" по графу

По полученному графу любой путь из началоного слова в конечное будет решением задачи о "лестнице слов". Но чтобы найти минимальную цепочку, воспользуемся алгоритмом А*.

Алгоритм А* работает путём последовательного просмотра отдельных уровней графа, начиная с узла-источника ***u*** . В данном случае узлом-источником будет являться узел, соответсвующий начальному слову.

Рассмотрим все рёбра ***(u,v)*** , выходящие из узла ***u*** . Если очередной узел ***v*** является целевым узлом, то поиск завершается; в противном случае узел ***v*** добавляется в очередь с приоритетом, где приоритетом является сумма эвристики (кол-во различающихся символов с конечным словом) и стоимости перехода в следующую точку из начальной. После того, как будут проверены все рёбра, выходящие из узла ***u***, из очереди извлекается следующий узел ***u***, и процесс повторяется.


## Пояснение к програмной реализации
 * [Выбор алгоритма и структур данных](#Выбор-алгоритма-и-структур-данных)
 * [Формат входных и выходных данных](#Формат-входных-и-выходных-данных)
 * [Запуск программы](#Запуск-программы)
 * [Сложность](#Сложность)
 * [Тесты](#Тесты)
 
 
### Выбор алгоритма и структур данных

В данной задаче разумно использовать граф и алгоритм поиска кратчайшего пути. Экспериментальным путем стало ясно, что граф выгоднее хранить с помощью списка ребер, так как работает быстрее, чем списком смежности, на существующих тестах.
Каждое ребро - неупорялоченная пара двух слов, так как граф является неориентированным.
Для поиска кратчайшего пути было решено использовать алгоритм А*. Он, в отличие от алгоритма Дейкстры, ищет путь между двумя вершинами, в то время как Дейкстра находит кратчайший путь до всех вершин.

### Формат входных и выходных данных

На вход программе подается файл, где на одной строке находятся 2 слова, разделенные пробелом - начальное и конечное. Результат программы записывается в файл ***output.txt***, на первой строке находится цепочка слов разделенная пробелами, если такова сущетсвует. В ином случае ***-1***.
Также программе необходим файл-словарь, со всеми (почти всеми) словами конкретного языка.

### Запуск программы

Так как программа написана на языке python, то достаточно запустить скрипт main.py с 2 аргументами командной строки - названия входного и выходного файлов.

### Сложность

#### Постороение графа
По реализованному алгоритму (описано в теоретической части - корзинки) граф хранится в виде пары 'корзинка' -> список слов.
Сложность построения - ***O(n * m^2)*** , где ***n*** - кол-во слов, ***m*** - длина слова. Требуется построить ***m*** корзинок за ***O(m)*** для ***n*** слов.

#### Алгоритм А*
В программе используется объект типа ***Queue.PriorityQueue*** , который реализован в виде кучи. Добавление в кучу происходит за ***O(logn)***.
Вычислительная сложность алгоритма А* совпадает с вычислительной сложностью алгоритма Дейкстры и равна ***O(E * logV)*** , где ***E*** - это кол-во ребер в графе, ***V*** - кол-во вершин (без учета вычисления сложности функции эвристики). ТАкая сложность достигается путем использования очереди с приоритетом, реализованной на куче.

### Тесты

Тестирование программы было сделано с помощью [nosetests](http://nose.readthedocs.io/en/latest/) для python.
В папке ***tests*** находятся файлы тестов, в результаты, а также покрытие кода содержит файл ***test_tesult.txt***

##### 001

input: hello world
output: -1
Путь не будет найден, так как не существует слов в языке, которые могут привести из первого слова во второе. Проверка flag в коде функции нахождения пути.

##### 002

input: could world
output: could would world
Осуществление двух замен букв.

##### 002
input: me by
output: me my by
Осуществление двух замен букв. Проверка на работу выделения нужных слов из словаря.

##### 004
input: two tea
output: two too ton ten tea
Сложный тест на корректность работы выбора по сумме текущей стоимости и эвристики.


##### 005
input: tree tide
output: tree free flee fled feed heed herd here hire hide tide
Аналогичен 4 тесту, проверка на длинные цепочки (более или менее длинные).

##### 006
input: specification investigation
output: -1
Слов данной длины в словаре мало, просто проверка.

##### 007
input: fool sage

output: -1

Не найден путь, так как слова ***sage*** в словаре нет. Проверка на существование слов.
